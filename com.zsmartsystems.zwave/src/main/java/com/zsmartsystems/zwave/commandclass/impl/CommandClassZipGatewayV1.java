/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.lang.IllegalArgumentException;
import java.util.HashMap;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>COMMAND_CLASS_ZIP_GATEWAY</b> version <b>1</b>.
 * <p>
 * Command Class Z/IP Gateway
 * <p>
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.
 * <p>
 * Command class key is 0x5F.
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassZipGatewayV1 {
    private static final Logger logger = LoggerFactory.getLogger(CommandClassZipGatewayV1.class);

    /**
     * Integer command class key for COMMAND_CLASS_ZIP_GATEWAY
     */
    public final static int COMMAND_CLASS_KEY = 0x5F;

    /**
     * Gateway Mode Set Command Constant
     */
    public final static int GATEWAY_MODE_SET = 0x01;
    /**
     * Gateway Mode Get Command Constant
     */
    public final static int GATEWAY_MODE_GET = 0x02;
    /**
     * Gateway Mode Report Command Constant
     */
    public final static int GATEWAY_MODE_REPORT = 0x03;
    /**
     * Gateway Peer Set Command Constant
     */
    public final static int GATEWAY_PEER_SET = 0x04;
    /**
     * Gateway Peer Get Command Constant
     */
    public final static int GATEWAY_PEER_GET = 0x05;
    /**
     * Gateway Peer Report Command Constant
     */
    public final static int GATEWAY_PEER_REPORT = 0x06;
    /**
     * Gateway Lock Set Command Constant
     */
    public final static int GATEWAY_LOCK_SET = 0x07;
    /**
     * Unsolicited Destination Set Command Constant
     */
    public final static int UNSOLICITED_DESTINATION_SET = 0x08;
    /**
     * Unsolicited Destination Get Command Constant
     */
    public final static int UNSOLICITED_DESTINATION_GET = 0x09;
    /**
     * Unsolicited Destination Report Command Constant
     */
    public final static int UNSOLICITED_DESTINATION_REPORT = 0x0A;
    /**
     * Application Node Info Set Command Constant
     */
    public final static int COMMAND_APPLICATION_NODE_INFO_SET = 0x0B;
    /**
     * Application Node Info Get Command Constant
     */
    public final static int COMMAND_APPLICATION_NODE_INFO_GET = 0x0C;
    /**
     * Application Node Info Report Command Constant
     */
    public final static int COMMAND_APPLICATION_NODE_INFO_REPORT = 0x0D;

    /**
     * Map holding constants for GatewayLockSetProperties1
     */
    private static Map<Integer, String> constantGatewayLockSetProperties1 = new HashMap<Integer, String>();

    /**
     * Map holding constants for GatewayModeSetMode
     */
    private static Map<Integer, String> constantGatewayModeSetMode = new HashMap<Integer, String>();

    /**
     * Map holding constants for CommandApplicationNodeInfoSetSecurityScheme0Mark
     */
    private static Map<Integer, String> constantCommandApplicationNodeInfoSetSecurityScheme0Mark = new HashMap<Integer, String>();

    /**
     * Map holding constants for GatewayModeReportMode
     */
    private static Map<Integer, String> constantGatewayModeReportMode = new HashMap<Integer, String>();

    /**
     * Map holding constants for CommandApplicationNodeInfoReportSecurityScheme0Mark
     */
    private static Map<Integer, String> constantCommandApplicationNodeInfoReportSecurityScheme0Mark = new HashMap<Integer, String>();

    static {
        // Constants for GatewayLockSetProperties1
        constantGatewayLockSetProperties1.put(0x01, "LOCK");
        constantGatewayLockSetProperties1.put(0x02, "SHOW");

        // Constants for GatewayModeSetMode
        constantGatewayModeSetMode.put(0x01, "STAND_ALONE");
        constantGatewayModeSetMode.put(0x02, "PORTAL");

        // Constants for CommandApplicationNodeInfoSetSecurityScheme0Mark
        constantCommandApplicationNodeInfoSetSecurityScheme0Mark.put(0x00, "SECURITY_SCHEME_0_MARK");
        constantCommandApplicationNodeInfoSetSecurityScheme0Mark.put(0xF1, "SECURITY_SCHEME_0_MARK");

        // Constants for GatewayModeReportMode
        constantGatewayModeReportMode.put(0x01, "STAND_ALONE");
        constantGatewayModeReportMode.put(0x02, "PORTAL");

        // Constants for CommandApplicationNodeInfoReportSecurityScheme0Mark
        constantCommandApplicationNodeInfoReportSecurityScheme0Mark.put(0x00, "SECURITY_SCHEME_0_MARK");
        constantCommandApplicationNodeInfoReportSecurityScheme0Mark.put(0xF1, "SECURITY_SCHEME_0_MARK");
    }

    /**
     * Creates a new message with the GATEWAY_MODE_SET command.
     * <p>
     * Gateway Mode Set
     *
     * @param mode {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>STAND_ALONE
     *            <li>PORTAL
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayModeSet(String mode) {
        logger.debug("Creating command message GATEWAY_MODE_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_MODE_SET);

        // Process 'Mode'
        boolean foundMode = false;
        for (Integer entry : constantGatewayModeSetMode.keySet()) {
            if (constantGatewayModeSetMode.get(entry).equals(mode)) {
                outputData.write(entry);
                foundMode = true;
                break;
            }
        }
        if (!foundMode) {
            throw new IllegalArgumentException("Unknown constant value '" + mode + "' for mode");
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_MODE_SET command.
     * <p>
     * Gateway Mode Set
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>MODE {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>STAND_ALONE
     * <li>PORTAL
     * </ul>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayModeSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Mode'
        response.put("MODE", constantGatewayModeSetMode.get(payload[2] & 0xff));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_MODE_GET command.
     * <p>
     * Gateway Mode Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayModeGet() {
        logger.debug("Creating command message GATEWAY_MODE_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_MODE_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_MODE_GET command.
     * <p>
     * Gateway Mode Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayModeGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_MODE_REPORT command.
     * <p>
     * Gateway Mode Report
     *
     * @param mode {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>STAND_ALONE
     *            <li>PORTAL
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayModeReport(String mode) {
        logger.debug("Creating command message GATEWAY_MODE_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_MODE_REPORT);

        // Process 'Mode'
        boolean foundMode = false;
        for (Integer entry : constantGatewayModeReportMode.keySet()) {
            if (constantGatewayModeReportMode.get(entry).equals(mode)) {
                outputData.write(entry);
                foundMode = true;
                break;
            }
        }
        if (!foundMode) {
            throw new IllegalArgumentException("Unknown constant value '" + mode + "' for mode");
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_MODE_REPORT command.
     * <p>
     * Gateway Mode Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>MODE {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>STAND_ALONE
     * <li>PORTAL
     * </ul>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayModeReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Mode'
        response.put("MODE", constantGatewayModeReportMode.get(payload[2] & 0xff));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_PEER_SET command.
     * <p>
     * Gateway Peer Set
     *
     * @param peerProfile {@link Integer}
     * @param ipv6Address {@link byte[]}
     * @param port {@link Integer}
     * @param peerName {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayPeerSet(Integer peerProfile, byte[] ipv6Address, Integer port, byte[] peerName) {
        logger.debug("Creating command message GATEWAY_PEER_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_PEER_SET);

        // Process 'Peer Profile'
        outputData.write(peerProfile);

        // Process 'IPv6 Address'
        if (ipv6Address != null) {
            if (ipv6Address.length > 16) {
                throw new IllegalArgumentException("Length of array ipv6Address exceeds maximum length of 16 bytes");
            }
            try {
                outputData.write(ipv6Address);
            } catch (IOException e) {
            }
        }

        // Process 'Port'
        outputData.write((port >> 8) & 0xff);
        outputData.write(port & 0xff);

        // Process 'Properties1'
        // Peer Name Length is used by 'Peer Name'
        int peerNameLength = peerName.length;
        outputData.write(peerNameLength & 0x3F);

        // Process 'Peer Name'
        if (peerName != null) {
            try {
                outputData.write(peerName);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_PEER_SET command.
     * <p>
     * Gateway Peer Set
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>PEER_PROFILE {@link Integer}
     * <li>IPV6_ADDRESS {@link byte[]}
     * <li>PORT {@link Integer}
     * <li>PEER_NAME {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayPeerSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Peer Profile'
        response.put("PEER_PROFILE", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'IPv6 Address'
        int lenIpv6Address = Math.min(16, payload.length - msgOffset);
        byte[] valIpv6Address = new byte[lenIpv6Address];
        for (int cntIpv6Address = 0; cntIpv6Address < lenIpv6Address; cntIpv6Address++) {
            valIpv6Address[cntIpv6Address] = payload[msgOffset + cntIpv6Address];
        }
        response.put("IPV6_ADDRESS", valIpv6Address);
        msgOffset += 16;

        // Process 'Port'
        response.put("PORT", Integer.valueOf(((payload[msgOffset] & 0xff) << 8) + (payload[msgOffset + 1] & 0xff)));
        msgOffset += 2;

        // Process 'Properties1'
        // Peer Name Length is used by 'Peer Name'
        int varPeerNameLength = payload[msgOffset] & 0x3F;
        msgOffset += 1;

        // Process 'Peer Name'
        ByteArrayOutputStream valPeerName = new ByteArrayOutputStream();
        for (int cntPeerName = 0; cntPeerName < varPeerNameLength; cntPeerName++) {
            valPeerName.write(payload[msgOffset + cntPeerName]);
        }
        response.put("PEER_NAME", valPeerName.toByteArray());
        msgOffset += varPeerNameLength;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_PEER_GET command.
     * <p>
     * Gateway Peer Get
     *
     * @param peerProfile {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayPeerGet(Integer peerProfile) {
        logger.debug("Creating command message GATEWAY_PEER_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_PEER_GET);

        // Process 'Peer Profile'
        outputData.write(peerProfile);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_PEER_GET command.
     * <p>
     * Gateway Peer Get
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>PEER_PROFILE {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayPeerGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Peer Profile'
        response.put("PEER_PROFILE", Integer.valueOf(payload[2]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_PEER_REPORT command.
     * <p>
     * Gateway Peer Report
     *
     * @param peerProfile {@link Integer}
     * @param peerCount {@link Integer}
     * @param ipv6Address {@link byte[]}
     * @param port {@link Integer}
     * @param peerName {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayPeerReport(Integer peerProfile, Integer peerCount, byte[] ipv6Address, Integer port,
            byte[] peerName) {
        logger.debug("Creating command message GATEWAY_PEER_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_PEER_REPORT);

        // Process 'Peer Profile'
        outputData.write(peerProfile);

        // Process 'Peer Count'
        outputData.write(peerCount);

        // Process 'IPv6 Address'
        if (ipv6Address != null) {
            if (ipv6Address.length > 16) {
                throw new IllegalArgumentException("Length of array ipv6Address exceeds maximum length of 16 bytes");
            }
            try {
                outputData.write(ipv6Address);
            } catch (IOException e) {
            }
        }

        // Process 'Port'
        outputData.write((port >> 8) & 0xff);
        outputData.write(port & 0xff);

        // Process 'Properties1'
        // Peer Name Length is used by 'Peer Name'
        int peerNameLength = peerName.length;
        outputData.write(peerNameLength & 0x3F);

        // Process 'Peer Name'
        if (peerName != null) {
            try {
                outputData.write(peerName);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_PEER_REPORT command.
     * <p>
     * Gateway Peer Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>PEER_PROFILE {@link Integer}
     * <li>PEER_COUNT {@link Integer}
     * <li>IPV6_ADDRESS {@link byte[]}
     * <li>PORT {@link Integer}
     * <li>PEER_NAME {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayPeerReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Peer Profile'
        response.put("PEER_PROFILE", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Peer Count'
        response.put("PEER_COUNT", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'IPv6 Address'
        int lenIpv6Address = Math.min(16, payload.length - msgOffset);
        byte[] valIpv6Address = new byte[lenIpv6Address];
        for (int cntIpv6Address = 0; cntIpv6Address < lenIpv6Address; cntIpv6Address++) {
            valIpv6Address[cntIpv6Address] = payload[msgOffset + cntIpv6Address];
        }
        response.put("IPV6_ADDRESS", valIpv6Address);
        msgOffset += 16;

        // Process 'Port'
        response.put("PORT", Integer.valueOf(((payload[msgOffset] & 0xff) << 8) + (payload[msgOffset + 1] & 0xff)));
        msgOffset += 2;

        // Process 'Properties1'
        // Peer Name Length is used by 'Peer Name'
        int varPeerNameLength = payload[msgOffset] & 0x3F;
        msgOffset += 1;

        // Process 'Peer Name'
        ByteArrayOutputStream valPeerName = new ByteArrayOutputStream();
        for (int cntPeerName = 0; cntPeerName < varPeerNameLength; cntPeerName++) {
            valPeerName.write(payload[msgOffset + cntPeerName]);
        }
        response.put("PEER_NAME", valPeerName.toByteArray());
        msgOffset += varPeerNameLength;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GATEWAY_LOCK_SET command.
     * <p>
     * Gateway Lock Set
     *
     * @param lock {@link Boolean}
     * @param show {@link Boolean}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGatewayLockSet(Boolean lock, Boolean show) {
        logger.debug("Creating command message GATEWAY_LOCK_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GATEWAY_LOCK_SET);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= lock ? 0x01 : 0;
        valProperties1 |= show ? 0x02 : 0;
        outputData.write(valProperties1);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GATEWAY_LOCK_SET command.
     * <p>
     * Gateway Lock Set
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>LOCK {@link Boolean}
     * <li>SHOW {@link Boolean}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGatewayLockSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("LOCK", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("SHOW", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the UNSOLICITED_DESTINATION_SET command.
     * <p>
     * Unsolicited Destination Set
     *
     * @param unsolicitedIpv6Destination {@link byte[]}
     * @param unsolicitedDestinationPort {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getUnsolicitedDestinationSet(byte[] unsolicitedIpv6Destination,
            Integer unsolicitedDestinationPort) {
        logger.debug("Creating command message UNSOLICITED_DESTINATION_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(UNSOLICITED_DESTINATION_SET);

        // Process 'Unsolicited IPv6 Destination'
        if (unsolicitedIpv6Destination != null) {
            if (unsolicitedIpv6Destination.length > 16) {
                throw new IllegalArgumentException("Length of array unsolicitedIpv6Destination exceeds maximum length of 16 bytes");
            }
            try {
                outputData.write(unsolicitedIpv6Destination);
            } catch (IOException e) {
            }
        }

        // Process 'Unsolicited Destination Port'
        outputData.write((unsolicitedDestinationPort >> 8) & 0xff);
        outputData.write(unsolicitedDestinationPort & 0xff);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the UNSOLICITED_DESTINATION_SET command.
     * <p>
     * Unsolicited Destination Set
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>UNSOLICITED_IPV6_DESTINATION {@link byte[]}
     * <li>UNSOLICITED_DESTINATION_PORT {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleUnsolicitedDestinationSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Unsolicited IPv6 Destination'
        int lenUnsolicitedIpv6Destination = Math.min(16, payload.length - 2);
        byte[] valUnsolicitedIpv6Destination = new byte[lenUnsolicitedIpv6Destination];
        for (int cntUnsolicitedIpv6Destination = 0; cntUnsolicitedIpv6Destination < lenUnsolicitedIpv6Destination; cntUnsolicitedIpv6Destination++) {
            valUnsolicitedIpv6Destination[cntUnsolicitedIpv6Destination] = payload[2 + cntUnsolicitedIpv6Destination];
        }
        response.put("UNSOLICITED_IPV6_DESTINATION", valUnsolicitedIpv6Destination);

        // Process 'Unsolicited Destination Port'
        response.put("UNSOLICITED_DESTINATION_PORT", Integer.valueOf(((payload[18] & 0xff) << 8) + (payload[19] & 0xff)));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the UNSOLICITED_DESTINATION_GET command.
     * <p>
     * Unsolicited Destination Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getUnsolicitedDestinationGet() {
        logger.debug("Creating command message UNSOLICITED_DESTINATION_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(UNSOLICITED_DESTINATION_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the UNSOLICITED_DESTINATION_GET command.
     * <p>
     * Unsolicited Destination Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleUnsolicitedDestinationGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the UNSOLICITED_DESTINATION_REPORT command.
     * <p>
     * Unsolicited Destination Report
     *
     * @param unsolicitedIpv6Destination {@link byte[]}
     * @param unsolicitedDestinationPort {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getUnsolicitedDestinationReport(byte[] unsolicitedIpv6Destination,
            Integer unsolicitedDestinationPort) {
        logger.debug("Creating command message UNSOLICITED_DESTINATION_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(UNSOLICITED_DESTINATION_REPORT);

        // Process 'Unsolicited IPv6 Destination'
        if (unsolicitedIpv6Destination != null) {
            if (unsolicitedIpv6Destination.length > 16) {
                throw new IllegalArgumentException("Length of array unsolicitedIpv6Destination exceeds maximum length of 16 bytes");
            }
            try {
                outputData.write(unsolicitedIpv6Destination);
            } catch (IOException e) {
            }
        }

        // Process 'Unsolicited Destination Port'
        outputData.write((unsolicitedDestinationPort >> 8) & 0xff);
        outputData.write(unsolicitedDestinationPort & 0xff);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the UNSOLICITED_DESTINATION_REPORT command.
     * <p>
     * Unsolicited Destination Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>UNSOLICITED_IPV6_DESTINATION {@link byte[]}
     * <li>UNSOLICITED_DESTINATION_PORT {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleUnsolicitedDestinationReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Unsolicited IPv6 Destination'
        int lenUnsolicitedIpv6Destination = Math.min(16, payload.length - 2);
        byte[] valUnsolicitedIpv6Destination = new byte[lenUnsolicitedIpv6Destination];
        for (int cntUnsolicitedIpv6Destination = 0; cntUnsolicitedIpv6Destination < lenUnsolicitedIpv6Destination; cntUnsolicitedIpv6Destination++) {
            valUnsolicitedIpv6Destination[cntUnsolicitedIpv6Destination] = payload[2 + cntUnsolicitedIpv6Destination];
        }
        response.put("UNSOLICITED_IPV6_DESTINATION", valUnsolicitedIpv6Destination);

        // Process 'Unsolicited Destination Port'
        response.put("UNSOLICITED_DESTINATION_PORT", Integer.valueOf(((payload[18] & 0xff) << 8) + (payload[19] & 0xff)));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_APPLICATION_NODE_INFO_SET command.
     * <p>
     * Application Node Info Set
     *
     * @param nonSecureCommandClass {@link byte[]}
     * @param securityScheme0CommandClass {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandApplicationNodeInfoSet(byte[] nonSecureCommandClass,
            byte[] securityScheme0CommandClass) {
        logger.debug("Creating command message COMMAND_APPLICATION_NODE_INFO_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_APPLICATION_NODE_INFO_SET);

        // Process 'Non-Secure Command Class'
        if (nonSecureCommandClass != null) {
            try {
                outputData.write(nonSecureCommandClass);
            } catch (IOException e) {
            }
        }

        // Process 'Security Scheme 0 MARK'
        outputData.write(0xF1);

        // Process 'Security Scheme 0 Command Class'
        if (securityScheme0CommandClass != null) {
            try {
                outputData.write(securityScheme0CommandClass);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_APPLICATION_NODE_INFO_SET command.
     * <p>
     * Application Node Info Set
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>NON_SECURE_COMMAND_CLASS {@link byte[]}
     * <li>SECURITY_SCHEME_0_COMMAND_CLASS {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandApplicationNodeInfoSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Non-Secure Command Class'
        ByteArrayOutputStream valNonSecureCommandClass = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            // Detect the marker
            if (((payload[msgOffset] & 0xFF) == 0xF1) && ((payload[msgOffset + 1] & 0xFF) == 0x00)) {
                break;
            }
            valNonSecureCommandClass.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("NON_SECURE_COMMAND_CLASS", valNonSecureCommandClass);

        // Process 'Security Scheme 0 MARK'
        // Adjust position to account for the marker
        msgOffset += 2;

        // Process 'Security Scheme 0 Command Class'
        ByteArrayOutputStream valSecurityScheme0CommandClass = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valSecurityScheme0CommandClass.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("SECURITY_SCHEME_0_COMMAND_CLASS", valSecurityScheme0CommandClass);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_APPLICATION_NODE_INFO_GET command.
     * <p>
     * Application Node Info Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandApplicationNodeInfoGet() {
        logger.debug("Creating command message COMMAND_APPLICATION_NODE_INFO_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_APPLICATION_NODE_INFO_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_APPLICATION_NODE_INFO_GET command.
     * <p>
     * Application Node Info Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandApplicationNodeInfoGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_APPLICATION_NODE_INFO_REPORT command.
     * <p>
     * Application Node Info Report
     *
     * @param nonSecureCommandClass {@link byte[]}
     * @param securityScheme0CommandClass {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandApplicationNodeInfoReport(byte[] nonSecureCommandClass,
            byte[] securityScheme0CommandClass) {
        logger.debug("Creating command message COMMAND_APPLICATION_NODE_INFO_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_APPLICATION_NODE_INFO_REPORT);

        // Process 'Non-Secure Command Class'
        if (nonSecureCommandClass != null) {
            try {
                outputData.write(nonSecureCommandClass);
            } catch (IOException e) {
            }
        }

        // Process 'Security Scheme 0 MARK'
        outputData.write(0xF1);

        // Process 'Security Scheme 0 Command Class'
        if (securityScheme0CommandClass != null) {
            try {
                outputData.write(securityScheme0CommandClass);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_APPLICATION_NODE_INFO_REPORT command.
     * <p>
     * Application Node Info Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>NON_SECURE_COMMAND_CLASS {@link byte[]}
     * <li>SECURITY_SCHEME_0_COMMAND_CLASS {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandApplicationNodeInfoReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Non-Secure Command Class'
        ByteArrayOutputStream valNonSecureCommandClass = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            // Detect the marker
            if (((payload[msgOffset] & 0xFF) == 0xF1) && ((payload[msgOffset + 1] & 0xFF) == 0x00)) {
                break;
            }
            valNonSecureCommandClass.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("NON_SECURE_COMMAND_CLASS", valNonSecureCommandClass);

        // Process 'Security Scheme 0 MARK'
        // Adjust position to account for the marker
        msgOffset += 2;

        // Process 'Security Scheme 0 Command Class'
        ByteArrayOutputStream valSecurityScheme0CommandClass = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valSecurityScheme0CommandClass.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("SECURITY_SCHEME_0_COMMAND_CLASS", valSecurityScheme0CommandClass);

        // Return the map of processed response data;
        return response;
    }
}
