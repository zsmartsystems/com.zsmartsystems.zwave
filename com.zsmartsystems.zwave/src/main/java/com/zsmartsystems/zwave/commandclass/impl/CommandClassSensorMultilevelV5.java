/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>COMMAND_CLASS_SENSOR_MULTILEVEL</b> version <b>5</b>.<br>
 * <p>
 * Command Class Sensor Multilevel<br>
 *
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.<br>
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassSensorMultilevelV5 {
    private static final Logger logger = LoggerFactory.getLogger(CommandClassSensorMultilevelV5.class);

    /**
     * Integer command class key for COMMAND_CLASS_SENSOR_MULTILEVEL
     */
    public final static int COMMAND_CLASS_KEY = 0x31;

    /**
     * Multilevel Sensor Get Supported Sensor Command Constant
     */
    public final static int SENSOR_MULTILEVEL_SUPPORTED_GET_SENSOR = 0x01;
    /**
     * Multilevel Sensor Supported Sensor Report Command Constant
     */
    public final static int SENSOR_MULTILEVEL_SUPPORTED_SENSOR_REPORT = 0x02;
    /**
     * Multilevel Sensor Get Supported Scale Command Constant
     */
    public final static int SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE = 0x03;
    /**
     * Multilevel Sensor Get Command Constant
     */
    public final static int SENSOR_MULTILEVEL_GET = 0x04;
    /**
     * Multilevel Sensor Report Command Constant
     */
    public final static int SENSOR_MULTILEVEL_REPORT = 0x05;
    /**
     * Multilevel Sensor Supported Scale Report Command Constant
     */
    public final static int SENSOR_MULTILEVEL_SUPPORTED_SCALE_REPORT = 0x06;

    // Constants for Sensor Type
    private static Map<Integer, String> constantSensorType = new HashMap<Integer, String>();

    static {
        // Constants for Sensor Type
        constantSensorType.put(0x01, "TEMPERATURE");
        constantSensorType.put(0x02, "GENERAL_PURPOSE_VALUE");
        constantSensorType.put(0x03, "LUMINANCE");
        constantSensorType.put(0x04, "POWER");
        constantSensorType.put(0x05, "RELATIVE_HUMIDITY");
        constantSensorType.put(0x06, "VELOCITY");
        constantSensorType.put(0x07, "DIRECTION");
        constantSensorType.put(0x08, "ATMOSPHERIC_PRESSURE");
        constantSensorType.put(0x09, "BAROMETRIC_PRESSURE");
        constantSensorType.put(0x0A, "SOLAR_RADIATION");
        constantSensorType.put(0x0B, "DEW_POINT");
        constantSensorType.put(0x0C, "RAIN_RATE");
        constantSensorType.put(0x0D, "TIDE_LEVEL");
        constantSensorType.put(0x0E, "WEIGHT");
        constantSensorType.put(0x0F, "VOLTAGE");
        constantSensorType.put(0x11, "CO2_LEVEL");
        constantSensorType.put(0x10, "CURRENT");
        constantSensorType.put(0x13, "TANK_CAPACITY");
        constantSensorType.put(0x12, "AIR_FLOW");
        constantSensorType.put(0x15, "ANGLE_POSITION");
        constantSensorType.put(0x14, "DISTANCE");
        constantSensorType.put(0x17, "WATER_TEMPERATURE");
        constantSensorType.put(0x16, "ROTATION");
        constantSensorType.put(0x19, "SEISMIC_INTENSITY");
        constantSensorType.put(0x18, "SOIL_TEMPERATURE");
        constantSensorType.put(0x1B, "ULTRAVIOLET");
        constantSensorType.put(0x1A, "SEISMIC_MAGNITUDE");
        constantSensorType.put(0x1D, "ELECTRICAL_CONDUCTIVITY");
        constantSensorType.put(0x1C, "ELECTRICAL_RESISTIVITY");
        constantSensorType.put(0x1F, "MOISTURE");
        constantSensorType.put(0x1E, "LOUDNESS");
    }

    /**
     * Creates a new message with the SENSOR_MULTILEVEL_SUPPORTED_GET_SENSOR command.<br>
     * <p>
     * Multilevel Sensor Get Supported Sensor<br>
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSensorMultilevelSupportedGetSensor() {
        logger.debug("Creating command message SENSOR_MULTILEVEL_SUPPORTED_GET_SENSOR version 5");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SENSOR_MULTILEVEL_SUPPORTED_GET_SENSOR);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SENSOR_MULTILEVEL_SUPPORTED_GET_SENSOR command<br>
     * <p>
     * Multilevel Sensor Get Supported Sensor<br>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSensorMultilevelSupportedGetSensor(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SENSOR_MULTILEVEL_SUPPORTED_SENSOR_REPORT command.<br>
     * <p>
     * Multilevel Sensor Supported Sensor Report<br>
     *
     * @param bitMask {@link List<String>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSensorMultilevelSupportedSensorReport(List<String> bitMask) {
        logger.debug("Creating command message SENSOR_MULTILEVEL_SUPPORTED_SENSOR_REPORT version 5");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SENSOR_MULTILEVEL_SUPPORTED_SENSOR_REPORT);

        // Process 'Bit Mask'
        int valBitMask = 0;
        valBitMask |= (bitMask.contains("AIR_TEMPERATURE") ? 0x02 : 0);
        valBitMask |= (bitMask.contains("GENERAL_PURPOSE_VALUE") ? 0x04 : 0);
        valBitMask |= (bitMask.contains("LUMINANCE") ? 0x08 : 0);
        valBitMask |= (bitMask.contains("POWER") ? 0x10 : 0);
        valBitMask |= (bitMask.contains("HUMIDITY") ? 0x20 : 0);
        valBitMask |= (bitMask.contains("VELOCITY") ? 0x40 : 0);
        valBitMask |= (bitMask.contains("DIRECTION") ? 0x80 : 0);
        outputData.write(valBitMask);
        valBitMask = 0;
        valBitMask |= (bitMask.contains("ATMOSPHERIC_PRESSURE") ? 0x01 : 0);
        valBitMask |= (bitMask.contains("BAROMETRIC_PRESSURE") ? 0x02 : 0);
        valBitMask |= (bitMask.contains("SOLAR_RADIATION") ? 0x04 : 0);
        valBitMask |= (bitMask.contains("DEW_POINT") ? 0x08 : 0);
        valBitMask |= (bitMask.contains("RAIN_RATE") ? 0x10 : 0);
        valBitMask |= (bitMask.contains("TIDE_LEVEL") ? 0x20 : 0);
        valBitMask |= (bitMask.contains("WEIGHT") ? 0x40 : 0);
        valBitMask |= (bitMask.contains("VOLTAGE") ? 0x80 : 0);
        outputData.write(valBitMask);
        valBitMask = 0;
        valBitMask |= (bitMask.contains("CURRENT") ? 0x01 : 0);
        valBitMask |= (bitMask.contains("CO2_LEVEL") ? 0x02 : 0);
        valBitMask |= (bitMask.contains("AIR_FLOW") ? 0x04 : 0);
        valBitMask |= (bitMask.contains("TANK_CAPACITY") ? 0x08 : 0);
        valBitMask |= (bitMask.contains("DISTANCE") ? 0x10 : 0);
        valBitMask |= (bitMask.contains("ANGLE_POSITION") ? 0x20 : 0);
        valBitMask |= (bitMask.contains("ROTATION") ? 0x40 : 0);
        valBitMask |= (bitMask.contains("WATER_TEMPERATURE") ? 0x80 : 0);
        outputData.write(valBitMask);
        valBitMask = 0;
        valBitMask |= (bitMask.contains("SOIL_TEMPERATURE") ? 0x01 : 0);
        valBitMask |= (bitMask.contains("SEISMIC_INTENSITY") ? 0x02 : 0);
        valBitMask |= (bitMask.contains("SEISMIC_MAGNITUDE") ? 0x04 : 0);
        valBitMask |= (bitMask.contains("ULTRAVIOLET") ? 0x08 : 0);
        valBitMask |= (bitMask.contains("ELECTRICAL_RESISTIVITY") ? 0x10 : 0);
        valBitMask |= (bitMask.contains("ELECTRICAL_CONDUCTIVITY") ? 0x20 : 0);
        valBitMask |= (bitMask.contains("LOUDNESS") ? 0x40 : 0);
        valBitMask |= (bitMask.contains("MOISTURE") ? 0x80 : 0);
        outputData.write(valBitMask);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SENSOR_MULTILEVEL_SUPPORTED_SENSOR_REPORT command<br>
     * <p>
     * Multilevel Sensor Supported Sensor Report<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>BIT_MASK {@link List}<{@link String}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSensorMultilevelSupportedSensorReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Bit Mask'
        List<String> responseBitMask = new ArrayList<String>();
        int cntBitMask = 0;
        while (cntBitMask < payload.length - 2) {
            if ((payload[2 + (cntBitMask / 8)] & cntBitMask % 8) == 0) {
                continue;
            }
            switch (cntBitMask) {
                case 0x01:
                    responseBitMask.add("AIR_TEMPERATURE");
                    break;
                case 0x02:
                    responseBitMask.add("GENERAL_PURPOSE_VALUE");
                    break;
                case 0x03:
                    responseBitMask.add("LUMINANCE");
                    break;
                case 0x04:
                    responseBitMask.add("POWER");
                    break;
                case 0x05:
                    responseBitMask.add("HUMIDITY");
                    break;
                case 0x06:
                    responseBitMask.add("VELOCITY");
                    break;
                case 0x07:
                    responseBitMask.add("DIRECTION");
                    break;
                case 0x08:
                    responseBitMask.add("ATMOSPHERIC_PRESSURE");
                    break;
                case 0x09:
                    responseBitMask.add("BAROMETRIC_PRESSURE");
                    break;
                case 0x0A:
                    responseBitMask.add("SOLAR_RADIATION");
                    break;
                case 0x0B:
                    responseBitMask.add("DEW_POINT");
                    break;
                case 0x0C:
                    responseBitMask.add("RAIN_RATE");
                    break;
                case 0x0D:
                    responseBitMask.add("TIDE_LEVEL");
                    break;
                case 0x0E:
                    responseBitMask.add("WEIGHT");
                    break;
                case 0x0F:
                    responseBitMask.add("VOLTAGE");
                    break;
                case 0x10:
                    responseBitMask.add("CURRENT");
                    break;
                case 0x11:
                    responseBitMask.add("CO2_LEVEL");
                    break;
                case 0x12:
                    responseBitMask.add("AIR_FLOW");
                    break;
                case 0x13:
                    responseBitMask.add("TANK_CAPACITY");
                    break;
                case 0x14:
                    responseBitMask.add("DISTANCE");
                    break;
                case 0x15:
                    responseBitMask.add("ANGLE_POSITION");
                    break;
                case 0x16:
                    responseBitMask.add("ROTATION");
                    break;
                case 0x17:
                    responseBitMask.add("WATER_TEMPERATURE");
                    break;
                case 0x18:
                    responseBitMask.add("SOIL_TEMPERATURE");
                    break;
                case 0x19:
                    responseBitMask.add("SEISMIC_INTENSITY");
                    break;
                case 0x1A:
                    responseBitMask.add("SEISMIC_MAGNITUDE");
                    break;
                case 0x1B:
                    responseBitMask.add("ULTRAVIOLET");
                    break;
                case 0x1C:
                    responseBitMask.add("ELECTRICAL_RESISTIVITY");
                    break;
                case 0x1D:
                    responseBitMask.add("ELECTRICAL_CONDUCTIVITY");
                    break;
                case 0x1E:
                    responseBitMask.add("LOUDNESS");
                    break;
                case 0x1F:
                    responseBitMask.add("MOISTURE");
                    break;
                default:
                    responseBitMask.add("BITMASK_" + cntBitMask);
                    break;
            }
        }
        response.put("BIT_MASK", responseBitMask);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE command.<br>
     * <p>
     * Multilevel Sensor Get Supported Scale<br>
     *
     * @param sensorType {@link String}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSensorMultilevelSupportedGetScale(String sensorType) {
        logger.debug("Creating command message SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE version 5");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE);

        // Process 'Sensor Type'
        for (Integer entry : constantSensorType.keySet()) {
            if (constantSensorType.get(entry).equals(sensorType)) {
                outputData.write(entry);
                break;
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SENSOR_MULTILEVEL_SUPPORTED_GET_SCALE command<br>
     * <p>
     * Multilevel Sensor Get Supported Scale<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SENSOR_TYPE {@link String}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSensorMultilevelSupportedGetScale(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sensor Type'
        constantSensorType.get((int) payload[2]);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SENSOR_MULTILEVEL_GET command.<br>
     * <p>
     * Multilevel Sensor Get<br>
     *
     * @param sensorType {@link String}
     * @param scale {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSensorMultilevelGet(String sensorType, Integer scale) {
        logger.debug("Creating command message SENSOR_MULTILEVEL_GET version 5");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SENSOR_MULTILEVEL_GET);

        // Process 'Sensor Type'
        for (Integer entry : constantSensorType.keySet()) {
            if (constantSensorType.get(entry).equals(sensorType)) {
                outputData.write(entry);
                break;
            }
        }

        // Process 'Properties1'
        outputData.write(((scale << 3) & 0x18));

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SENSOR_MULTILEVEL_GET command<br>
     * <p>
     * Multilevel Sensor Get<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SENSOR_TYPE {@link String}
     * <li>SCALE {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSensorMultilevelGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sensor Type'
        constantSensorType.get((int) payload[2]);

        // Process 'Properties1'
        response.put("SCALE", Integer.valueOf((payload[3] & 0x18 >> 3)));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SENSOR_MULTILEVEL_REPORT command.<br>
     * <p>
     * Multilevel Sensor Report<br>
     *
     * @param sensorType {@link String}
     * @param size {@link Integer}
     * @param scale {@link Integer}
     * @param precision {@link Integer}
     * @param sensorValue {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSensorMultilevelReport(String sensorType, Integer size, Integer scale, Integer precision,
            byte[] sensorValue) {
        logger.debug("Creating command message SENSOR_MULTILEVEL_REPORT version 5");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SENSOR_MULTILEVEL_REPORT);

        // Process 'Sensor Type'
        for (Integer entry : constantSensorType.keySet()) {
            if (constantSensorType.get(entry).equals(sensorType)) {
                outputData.write(entry);
                break;
            }
        }

        // Process 'Level'
        int valLevel = 0;
        valLevel |= size & 0x07;
        valLevel |= ((scale << 3) & 0x18);
        valLevel |= ((precision << 5) & 0xE0);
        outputData.write(valLevel);

        // Process 'Sensor Value'
        try {
            outputData.write(sensorValue);
        } catch (IOException e) {
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SENSOR_MULTILEVEL_REPORT command<br>
     * <p>
     * Multilevel Sensor Report<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SENSOR_TYPE {@link String}
     * <li>SIZE {@link Integer}
     * <li>SCALE {@link Integer}
     * <li>PRECISION {@link Integer}
     * <li>SENSOR_VALUE {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSensorMultilevelReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Sensor Type'
        constantSensorType.get((int) payload[msgOffset]);
        msgOffset += 1;

        // Process 'Level'
        response.put("SIZE", Integer.valueOf(payload[msgOffset] & 0x07));
        response.put("SCALE", Integer.valueOf((payload[msgOffset] & 0x18 >> 3)));
        response.put("PRECISION", Integer.valueOf((payload[msgOffset] & 0xE0 >> 5)));
        msgOffset += 1;

        // Process 'Sensor Value'
        int valSensorValue = 0;
        int lenSensorValue = payload[msgOffset - 1] & 0x07;
        for (int cntSensorValue = 0; cntSensorValue < lenSensorValue; cntSensorValue++) {
            valSensorValue = (valSensorValue << 8) + payload[msgOffset + cntSensorValue];
        }
        response.put("SENSOR_VALUE", valSensorValue);
        msgOffset += lenSensorValue;

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SENSOR_MULTILEVEL_SUPPORTED_SCALE_REPORT command.<br>
     * <p>
     * Multilevel Sensor Supported Scale Report<br>
     *
     * @param sensorType {@link String}
     * @param scaleBitMask {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSensorMultilevelSupportedScaleReport(String sensorType, Integer scaleBitMask) {
        logger.debug("Creating command message SENSOR_MULTILEVEL_SUPPORTED_SCALE_REPORT version 5");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SENSOR_MULTILEVEL_SUPPORTED_SCALE_REPORT);

        // Process 'Sensor Type'
        for (Integer entry : constantSensorType.keySet()) {
            if (constantSensorType.get(entry).equals(sensorType)) {
                outputData.write(entry);
                break;
            }
        }

        // Process 'Properties1'
        outputData.write(scaleBitMask & 0x0F);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SENSOR_MULTILEVEL_SUPPORTED_SCALE_REPORT command<br>
     * <p>
     * Multilevel Sensor Supported Scale Report<br>
     * <p>
     * The output data {@link Map} has the following properties<br>
     *
     * <ul>
     * <li>SENSOR_TYPE {@link String}
     * <li>SCALE_BIT_MASK {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSensorMultilevelSupportedScaleReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sensor Type'
        constantSensorType.get((int) payload[2]);

        // Process 'Properties1'
        response.put("SCALE_BIT_MASK", Integer.valueOf(payload[3] & 0x0F));

        // Return the map of processed response data;
        return response;
    }

}
