/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.lang.IllegalArgumentException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>COMMAND_CLASS_SECURITY_2</b> version <b>1</b>.
 * <p>
 * Command Class Security 2
 * <p>
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.
 * <p>
 * Command class key is 0x9F.
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class CommandClassSecurity2V1 {
    private static final Logger logger = LoggerFactory.getLogger(CommandClassSecurity2V1.class);

    /**
     * Integer command class key for COMMAND_CLASS_SECURITY_2
     */
    public final static int COMMAND_CLASS_KEY = 0x9F;

    /**
     * S2 Nonce Get Command Constant
     */
    public final static int SECURITY_2_NONCE_GET = 0x01;
    /**
     * S2 Nonce Report Command Constant
     */
    public final static int SECURITY_2_NONCE_REPORT = 0x02;
    /**
     * S2 Message Encapsulation Command Constant
     */
    public final static int SECURITY_2_MESSAGE_ENCAPSULATION = 0x03;
    /**
     * KEX Get Command Constant
     */
    public final static int KEX_GET = 0x04;
    /**
     * KEX Report Command Constant
     */
    public final static int KEX_REPORT = 0x05;
    /**
     * KEX Set Command Constant
     */
    public final static int KEX_SET = 0x06;
    /**
     * KEX Fail Command Constant
     */
    public final static int KEX_FAIL = 0x07;
    /**
     * Public Key Report Command Constant
     */
    public final static int PUBLIC_KEY_REPORT = 0x08;
    /**
     * S2 Network Key Get Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_GET = 0x09;
    /**
     * S2 Network Key Report Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_REPORT = 0x0A;
    /**
     * S2 Network Key Verify Command Constant
     */
    public final static int SECURITY_2_NETWORK_KEY_VERIFY = 0x0B;
    /**
     * S2 Transfer End Command Constant
     */
    public final static int SECURITY_2_TRANSFER_END = 0x0C;
    /**
     * S2 Commands Supported Get Command Constant
     */
    public final static int SECURITY_2_COMMANDS_SUPPORTED_GET = 0x0D;
    /**
     * S2 Commands Supported Report Command Constant
     */
    public final static int SECURITY_2_COMMANDS_SUPPORTED_REPORT = 0x0E;
    /**
     * S2 Capabilities Get Command Constant
     */
    public final static int SECURITY_2_CAPABILITIES_GET = 0x0F;
    /**
     * S2 Capabilities Report Command Constant
     */
    public final static int SECURITY_2_CAPABILITIES_REPORT = 0x10;

    /**
     * Map holding constants for Security2TransferEndProperties1
     */
    private static Map<Integer, String> constantSecurity2TransferEndProperties1 = new HashMap<Integer, String>();

    /**
     * Map holding constants for KexSetGrantedKeys
     */
    private static Map<Integer, String> constantKexSetGrantedKeys = new HashMap<Integer, String>();

    /**
     * Map holding constants for PublicKeyReportProperties1
     */
    private static Map<Integer, String> constantPublicKeyReportProperties1 = new HashMap<Integer, String>();

    /**
     * Map holding constants for KexReportRequestedKeys
     */
    private static Map<Integer, String> constantKexReportRequestedKeys = new HashMap<Integer, String>();

    /**
     * Map holding constants for Security2NetworkKeyGetRequestedKey
     */
    private static Map<Integer, String> constantSecurity2NetworkKeyGetRequestedKey = new HashMap<Integer, String>();

    /**
     * Map holding constants for Security2NetworkKeyReportGrantedKey
     */
    private static Map<Integer, String> constantSecurity2NetworkKeyReportGrantedKey = new HashMap<Integer, String>();

    /**
     * Map holding constants for KexSetProperties1
     */
    private static Map<Integer, String> constantKexSetProperties1 = new HashMap<Integer, String>();

    /**
     * Map holding constants for KexReportProperties1
     */
    private static Map<Integer, String> constantKexReportProperties1 = new HashMap<Integer, String>();

    /**
     * Map holding constants for KexFailKexFailType
     */
    private static Map<Integer, String> constantKexFailKexFailType = new HashMap<Integer, String>();

    /**
     * Map holding constants for Security2MessageEncapsulationProperties1
     */
    private static Map<Integer, String> constantSecurity2MessageEncapsulationProperties1 = new HashMap<Integer, String>();

    /**
     * Map holding constants for Security2NonceReportProperties1
     */
    private static Map<Integer, String> constantSecurity2NonceReportProperties1 = new HashMap<Integer, String>();

    static {
        // Constants for Security2TransferEndProperties1
        constantSecurity2TransferEndProperties1.put(0x01, "KEY_REQUEST_COMPLETE");
        constantSecurity2TransferEndProperties1.put(0x02, "KEY_VERIFIED");

        // Constants for KexSetGrantedKeys
        constantKexSetGrantedKeys.put(0x00, "UNAUTHENTICATED");
        constantKexSetGrantedKeys.put(0x01, "AUTHENTICATED");
        constantKexSetGrantedKeys.put(0x02, "ACCESS");
        constantKexSetGrantedKeys.put(0x07, "S0");

        // Constants for PublicKeyReportProperties1
        constantPublicKeyReportProperties1.put(0x01, "INCLUDING_NODE");

        // Constants for KexReportRequestedKeys
        constantKexReportRequestedKeys.put(0x00, "UNAUTHENTICATED");
        constantKexReportRequestedKeys.put(0x01, "AUTHENTICATED");
        constantKexReportRequestedKeys.put(0x02, "ACCESS");
        constantKexReportRequestedKeys.put(0x07, "S0");

        // Constants for Security2NetworkKeyGetRequestedKey
        constantSecurity2NetworkKeyGetRequestedKey.put(0x00, "UNAUTHENTICATED");
        constantSecurity2NetworkKeyGetRequestedKey.put(0x01, "AUTHENTICATED");
        constantSecurity2NetworkKeyGetRequestedKey.put(0x02, "ACCESS");
        constantSecurity2NetworkKeyGetRequestedKey.put(0x07, "S0");

        // Constants for Security2NetworkKeyReportGrantedKey
        constantSecurity2NetworkKeyReportGrantedKey.put(0x00, "UNAUTHENTICATED");
        constantSecurity2NetworkKeyReportGrantedKey.put(0x01, "AUTHENTICATED");
        constantSecurity2NetworkKeyReportGrantedKey.put(0x02, "ACCESS");
        constantSecurity2NetworkKeyReportGrantedKey.put(0x07, "S0");

        // Constants for KexSetProperties1
        constantKexSetProperties1.put(0x01, "ECHO");
        constantKexSetProperties1.put(0x02, "REQUEST_CSA");

        // Constants for KexReportProperties1
        constantKexReportProperties1.put(0x01, "ECHO");
        constantKexReportProperties1.put(0x02, "REQUEST_CSA");

        // Constants for KexFailKexFailType
        constantKexFailKexFailType.put(0x01, "KEX_KEY");
        constantKexFailKexFailType.put(0x02, "KEX_SCHEME");
        constantKexFailKexFailType.put(0x03, "KEX_CURVES");
        constantKexFailKexFailType.put(0x05, "DECRYPT");
        constantKexFailKexFailType.put(0x06, "CANCEL");
        constantKexFailKexFailType.put(0x07, "AUTH");
        constantKexFailKexFailType.put(0x08, "KEY_GET");
        constantKexFailKexFailType.put(0x09, "KEY_VERIFY");
        constantKexFailKexFailType.put(0x0A, "KEY_REPORT");

        // Constants for Security2MessageEncapsulationProperties1
        constantSecurity2MessageEncapsulationProperties1.put(0x40, "CRITICAL");
        constantSecurity2MessageEncapsulationProperties1.put(0x80, "MORE_TO_FOLLOW");

        // Constants for Security2NonceReportProperties1
        constantSecurity2NonceReportProperties1.put(0x01, "SOS");
        constantSecurity2NonceReportProperties1.put(0x02, "MOS");
    }

    /**
     * Creates a new message with the SECURITY_2_NONCE_GET command.
     * <p>
     * S2 Nonce Get
     *
     * @param sequenceNumber {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NonceGet(Integer sequenceNumber) {
        logger.debug("Creating command message SECURITY_2_NONCE_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NONCE_GET);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NONCE_GET command.
     * <p>
     * S2 Nonce Get
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NonceGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[2]));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_NONCE_REPORT command.
     * <p>
     * S2 Nonce Report
     *
     * @param sequenceNumber {@link Integer}
     * @param sos {@link Boolean}
     * @param mos {@link Boolean}
     * @param receiversEntropyInput {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NonceReport(Integer sequenceNumber, Boolean sos, Boolean mos,
            byte[] receiversEntropyInput) {
        logger.debug("Creating command message SECURITY_2_NONCE_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NONCE_REPORT);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= sos ? 0x01 : 0;
        valProperties1 |= mos ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Receivers Entropy Input'
        if (receiversEntropyInput != null) {
            if (receiversEntropyInput.length > 16) {
                throw new IllegalArgumentException("Length of array receiversEntropyInput exceeds maximum length of 16 bytes");
            }
            try {
                outputData.write(receiversEntropyInput);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NONCE_REPORT command.
     * <p>
     * S2 Nonce Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * <li>SOS {@link Boolean}
     * <li>MOS {@link Boolean}
     * <li>RECEIVERS_ENTROPY_INPUT {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NonceReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[2]));

        // Process 'Properties1'
        response.put("SOS", Boolean.valueOf((payload[3] & 0x01) != 0));
        response.put("MOS", Boolean.valueOf((payload[3] & 0x02) != 0));

        // Process 'Receivers Entropy Input'
        int lenReceiversEntropyInput = Math.min(16, payload.length - 4);
        byte[] valReceiversEntropyInput = new byte[lenReceiversEntropyInput];
        for (int cntReceiversEntropyInput = 0; cntReceiversEntropyInput < lenReceiversEntropyInput; cntReceiversEntropyInput++) {
            valReceiversEntropyInput[cntReceiversEntropyInput] = payload[4 + cntReceiversEntropyInput];
        }
        response.put("RECEIVERS_ENTROPY_INPUT", valReceiversEntropyInput);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_MESSAGE_ENCAPSULATION command.
     * <p>
     * S2 Message Encapsulation
     *
     * @param sequenceNumber {@link Integer}
     * @param extension {@link Boolean}
     * @param encryptedExtension {@link Boolean}
     * @param ccmCiphertextObject {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2MessageEncapsulation(Integer sequenceNumber, Boolean extension,
            Boolean encryptedExtension, byte[] ccmCiphertextObject) {
        logger.debug("Creating command message SECURITY_2_MESSAGE_ENCAPSULATION version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_MESSAGE_ENCAPSULATION);

        // Process 'Sequence Number'
        outputData.write(sequenceNumber);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= extension ? 0x01 : 0;
        valProperties1 |= encryptedExtension ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'vg1'

        // Process 'CCM Ciphertext Object'
        if (ccmCiphertextObject != null) {
            try {
                outputData.write(ccmCiphertextObject);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_MESSAGE_ENCAPSULATION command.
     * <p>
     * S2 Message Encapsulation
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>SEQUENCE_NUMBER {@link Integer}
     * <li>EXTENSION {@link Boolean}
     * <li>ENCRYPTED_EXTENSION {@link Boolean}
     * <li>CCM_CIPHERTEXT_OBJECT {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2MessageEncapsulation(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Sequence Number'
        response.put("SEQUENCE_NUMBER", Integer.valueOf(payload[msgOffset]));
        msgOffset += 1;

        // Process 'Properties1'
        response.put("EXTENSION", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        response.put("ENCRYPTED_EXTENSION", Boolean.valueOf((payload[msgOffset] & 0x02) != 0));
        msgOffset += 1;

        // Process 'vg1'

        // Create a list to hold the group vg1
        List<Map<String, Object>> variantList = new ArrayList<Map<String, Object>>();

        int offset = msgOffset;
        while (offset < payload.length) {
            // Create a map to hold the members of this variant
            Map<String, Object> variant = new HashMap<String, Object>();

            // Process 'Extension Length'
            variant.put("EXTENSION_LENGTH", Integer.valueOf(payload[msgOffset]));
            msgOffset += 1;

            // Process 'Properties1'
            variant.put("TYPE", Integer.valueOf(payload[msgOffset] & 0x3F));
            variant.put("CRITICAL", Boolean.valueOf((payload[msgOffset] & 0x40) != 0));
            variant.put("MORE_TO_FOLLOW", Boolean.valueOf((payload[msgOffset] & 0x80) != 0));
            msgOffset += 1;

            // Process 'Extension'
            variant.put("EXTENSION", Integer.valueOf(payload[msgOffset]));
            msgOffset += payload[msgOffset - 2];

        }

        // Add the variant list to the response
        response.put("VG1", variantList);

        // Process 'CCM Ciphertext Object'
        ByteArrayOutputStream valCcmCiphertextObject = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valCcmCiphertextObject.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("CCM_CIPHERTEXT_OBJECT", valCcmCiphertextObject);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the KEX_GET command.
     * <p>
     * KEX Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexGet() {
        logger.debug("Creating command message KEX_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_GET command.
     * <p>
     * KEX Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the KEX_REPORT command.
     * <p>
     * KEX Report
     *
     * @param echo {@link Boolean}
     * @param requestCsa {@link Boolean}
     * @param supportedKexSchemes {@link Integer}
     * @param supportedEcdhProfiles {@link Integer}
     * @param requestedKeys {@link List<String>}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>UNAUTHENTICATED
     *            <li>AUTHENTICATED
     *            <li>ACCESS
     *            <li>S0
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexReport(Boolean echo, Boolean requestCsa, Integer supportedKexSchemes,
            Integer supportedEcdhProfiles, List<String> requestedKeys) {
        logger.debug("Creating command message KEX_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_REPORT);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= echo ? 0x01 : 0;
        valProperties1 |= requestCsa ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Supported KEX Schemes'
        outputData.write(supportedKexSchemes);

        // Process 'Supported ECDH Profiles'
        outputData.write(supportedEcdhProfiles);

        // Process 'Requested Keys'
        int valRequestedKeys = 0;
        for (String value : requestedKeys) {
            boolean foundRequestedKeys = false;
            for (Integer entry : constantKexReportRequestedKeys.keySet()) {
                if (constantKexReportRequestedKeys.get(entry).equals(value)) {
                    foundRequestedKeys = true;
                    valRequestedKeys += entry;
                    break;
                }
            }
            if (!foundRequestedKeys) {
                throw new IllegalArgumentException("Unknown constant value '" + requestedKeys + "' for requestedKeys");
            }
        }
        outputData.write(valRequestedKeys);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_REPORT command.
     * <p>
     * KEX Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>ECHO {@link Boolean}
     * <li>REQUEST_CSA {@link Boolean}
     * <li>SUPPORTED_KEX_SCHEMES {@link Integer}
     * <li>SUPPORTED_ECDH_PROFILES {@link Integer}
     * <li>REQUESTED_KEYS {@link List}<{@link String}>
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>UNAUTHENTICATED
     * <li>AUTHENTICATED
     * <li>ACCESS
     * <li>S0
     * </ul>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("ECHO", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("REQUEST_CSA", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Process 'Supported KEX Schemes'
        response.put("SUPPORTED_KEX_SCHEMES", Integer.valueOf(payload[3]));

        // Process 'Supported ECDH Profiles'
        response.put("SUPPORTED_ECDH_PROFILES", Integer.valueOf(payload[4]));

        // Process 'Requested Keys'
        List<String> responseRequestedKeys = new ArrayList<String>();
        int lenRequestedKeys = 1;
        for (int cntRequestedKeys = 0; cntRequestedKeys < lenRequestedKeys; cntRequestedKeys++) {
            if ((payload[5 + (cntRequestedKeys / 8)] & (1 << cntRequestedKeys % 8)) == 0) {
                continue;
            }
            responseRequestedKeys.add(constantKexReportRequestedKeys.get(cntRequestedKeys));
        }
        response.put("REQUESTED_KEYS", responseRequestedKeys);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the KEX_SET command.
     * <p>
     * KEX Set
     *
     * @param echo {@link Boolean}
     * @param requestCsa {@link Boolean}
     * @param selectedKexScheme {@link Integer}
     * @param selectedEcdhProfile {@link Integer}
     * @param grantedKeys {@link List<String>}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>UNAUTHENTICATED
     *            <li>AUTHENTICATED
     *            <li>ACCESS
     *            <li>S0
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexSet(Boolean echo, Boolean requestCsa, Integer selectedKexScheme,
            Integer selectedEcdhProfile, List<String> grantedKeys) {
        logger.debug("Creating command message KEX_SET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_SET);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= echo ? 0x01 : 0;
        valProperties1 |= requestCsa ? 0x02 : 0;
        outputData.write(valProperties1);

        // Process 'Selected KEX Scheme'
        outputData.write(selectedKexScheme);

        // Process 'Selected ECDH Profile'
        outputData.write(selectedEcdhProfile);

        // Process 'Granted Keys'
        int valGrantedKeys = 0;
        for (String value : grantedKeys) {
            boolean foundGrantedKeys = false;
            for (Integer entry : constantKexSetGrantedKeys.keySet()) {
                if (constantKexSetGrantedKeys.get(entry).equals(value)) {
                    foundGrantedKeys = true;
                    valGrantedKeys += entry;
                    break;
                }
            }
            if (!foundGrantedKeys) {
                throw new IllegalArgumentException("Unknown constant value '" + grantedKeys + "' for grantedKeys");
            }
        }
        outputData.write(valGrantedKeys);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_SET command.
     * <p>
     * KEX Set
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>ECHO {@link Boolean}
     * <li>REQUEST_CSA {@link Boolean}
     * <li>SELECTED_KEX_SCHEME {@link Integer}
     * <li>SELECTED_ECDH_PROFILE {@link Integer}
     * <li>GRANTED_KEYS {@link List}<{@link String}>
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>UNAUTHENTICATED
     * <li>AUTHENTICATED
     * <li>ACCESS
     * <li>S0
     * </ul>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexSet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("ECHO", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("REQUEST_CSA", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Process 'Selected KEX Scheme'
        response.put("SELECTED_KEX_SCHEME", Integer.valueOf(payload[3]));

        // Process 'Selected ECDH Profile'
        response.put("SELECTED_ECDH_PROFILE", Integer.valueOf(payload[4]));

        // Process 'Granted Keys'
        List<String> responseGrantedKeys = new ArrayList<String>();
        int lenGrantedKeys = 1;
        for (int cntGrantedKeys = 0; cntGrantedKeys < lenGrantedKeys; cntGrantedKeys++) {
            if ((payload[5 + (cntGrantedKeys / 8)] & (1 << cntGrantedKeys % 8)) == 0) {
                continue;
            }
            responseGrantedKeys.add(constantKexSetGrantedKeys.get(cntGrantedKeys));
        }
        response.put("GRANTED_KEYS", responseGrantedKeys);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the KEX_FAIL command.
     * <p>
     * KEX Fail
     *
     * @param kexFailType {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>KEX_KEY
     *            <li>KEX_SCHEME
     *            <li>KEX_CURVES
     *            <li>DECRYPT
     *            <li>CANCEL
     *            <li>AUTH
     *            <li>KEY_GET
     *            <li>KEY_VERIFY
     *            <li>KEY_REPORT
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getKexFail(String kexFailType) {
        logger.debug("Creating command message KEX_FAIL version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(KEX_FAIL);

        // Process 'KEX Fail Type'
        boolean foundKexFailType = false;
        for (Integer entry : constantKexFailKexFailType.keySet()) {
            if (constantKexFailKexFailType.get(entry).equals(kexFailType)) {
                outputData.write(entry);
                foundKexFailType = true;
                break;
            }
        }
        if (!foundKexFailType) {
            throw new IllegalArgumentException("Unknown constant value '" + kexFailType + "' for kexFailType");
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the KEX_FAIL command.
     * <p>
     * KEX Fail
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>KEX_FAIL_TYPE {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>KEX_KEY
     * <li>KEX_SCHEME
     * <li>KEX_CURVES
     * <li>DECRYPT
     * <li>CANCEL
     * <li>AUTH
     * <li>KEY_GET
     * <li>KEY_VERIFY
     * <li>KEY_REPORT
     * </ul>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleKexFail(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'KEX Fail Type'
        response.put("KEX_FAIL_TYPE", constantKexFailKexFailType.get(payload[2] & 0xff));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the PUBLIC_KEY_REPORT command.
     * <p>
     * Public Key Report
     *
     * @param includingNode {@link Boolean}
     * @param ecdhPublicKey {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getPublicKeyReport(Boolean includingNode, byte[] ecdhPublicKey) {
        logger.debug("Creating command message PUBLIC_KEY_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(PUBLIC_KEY_REPORT);

        // Process 'Properties1'
        outputData.write(includingNode ? 0x01 : 0);

        // Process 'ECDH Public Key'
        if (ecdhPublicKey != null) {
            try {
                outputData.write(ecdhPublicKey);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the PUBLIC_KEY_REPORT command.
     * <p>
     * Public Key Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>INCLUDING_NODE {@link Boolean}
     * <li>ECDH_PUBLIC_KEY {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handlePublicKeyReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Properties1'
        response.put("INCLUDING_NODE", Boolean.valueOf((payload[msgOffset] & 0x01) != 0));
        msgOffset += 1;

        // Process 'ECDH Public Key'
        ByteArrayOutputStream valEcdhPublicKey = new ByteArrayOutputStream();
        while (msgOffset < payload.length) {
            valEcdhPublicKey.write(payload[msgOffset]);
            msgOffset++;
        }
        response.put("ECDH_PUBLIC_KEY", valEcdhPublicKey);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_GET command.
     * <p>
     * S2 Network Key Get
     *
     * @param requestedKey {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>UNAUTHENTICATED
     *            <li>AUTHENTICATED
     *            <li>ACCESS
     *            <li>S0
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyGet(String requestedKey) {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_GET);

        // Process 'Requested Key'
        boolean foundRequestedKey = false;
        for (Integer entry : constantSecurity2NetworkKeyGetRequestedKey.keySet()) {
            if (constantSecurity2NetworkKeyGetRequestedKey.get(entry).equals(requestedKey)) {
                outputData.write(entry);
                foundRequestedKey = true;
                break;
            }
        }
        if (!foundRequestedKey) {
            throw new IllegalArgumentException("Unknown constant value '" + requestedKey + "' for requestedKey");
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_GET command.
     * <p>
     * S2 Network Key Get
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>REQUESTED_KEY {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>UNAUTHENTICATED
     * <li>AUTHENTICATED
     * <li>ACCESS
     * <li>S0
     * </ul>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Requested Key'
        response.put("REQUESTED_KEY", constantSecurity2NetworkKeyGetRequestedKey.get(payload[2] & 0xff));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_REPORT command.
     * <p>
     * S2 Network Key Report
     *
     * @param grantedKey {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>UNAUTHENTICATED
     *            <li>AUTHENTICATED
     *            <li>ACCESS
     *            <li>S0
     *            </ul>
     * @param networkKey {@link byte[]}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyReport(String grantedKey, byte[] networkKey) {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_REPORT);

        // Process 'Granted Key'
        boolean foundGrantedKey = false;
        for (Integer entry : constantSecurity2NetworkKeyReportGrantedKey.keySet()) {
            if (constantSecurity2NetworkKeyReportGrantedKey.get(entry).equals(grantedKey)) {
                outputData.write(entry);
                foundGrantedKey = true;
                break;
            }
        }
        if (!foundGrantedKey) {
            throw new IllegalArgumentException("Unknown constant value '" + grantedKey + "' for grantedKey");
        }

        // Process 'Network Key'
        if (networkKey != null) {
            if (networkKey.length > 16) {
                throw new IllegalArgumentException("Length of array networkKey exceeds maximum length of 16 bytes");
            }
            try {
                outputData.write(networkKey);
            } catch (IOException e) {
            }
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_REPORT command.
     * <p>
     * S2 Network Key Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>GRANTED_KEY {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>UNAUTHENTICATED
     * <li>AUTHENTICATED
     * <li>ACCESS
     * <li>S0
     * </ul>
     * <li>NETWORK_KEY {@link byte[]}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Granted Key'
        response.put("GRANTED_KEY", constantSecurity2NetworkKeyReportGrantedKey.get(payload[2] & 0xff));

        // Process 'Network Key'
        int lenNetworkKey = Math.min(16, payload.length - 3);
        byte[] valNetworkKey = new byte[lenNetworkKey];
        for (int cntNetworkKey = 0; cntNetworkKey < lenNetworkKey; cntNetworkKey++) {
            valNetworkKey[cntNetworkKey] = payload[3 + cntNetworkKey];
        }
        response.put("NETWORK_KEY", valNetworkKey);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_NETWORK_KEY_VERIFY command.
     * <p>
     * S2 Network Key Verify
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2NetworkKeyVerify() {
        logger.debug("Creating command message SECURITY_2_NETWORK_KEY_VERIFY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_NETWORK_KEY_VERIFY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_NETWORK_KEY_VERIFY command.
     * <p>
     * S2 Network Key Verify
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2NetworkKeyVerify(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_TRANSFER_END command.
     * <p>
     * S2 Transfer End
     *
     * @param keyRequestComplete {@link Boolean}
     * @param keyVerified {@link Boolean}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2TransferEnd(Boolean keyRequestComplete, Boolean keyVerified) {
        logger.debug("Creating command message SECURITY_2_TRANSFER_END version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_TRANSFER_END);

        // Process 'Properties1'
        int valProperties1 = 0;
        valProperties1 |= keyRequestComplete ? 0x01 : 0;
        valProperties1 |= keyVerified ? 0x02 : 0;
        outputData.write(valProperties1);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_TRANSFER_END command.
     * <p>
     * S2 Transfer End
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>KEY_REQUEST_COMPLETE {@link Boolean}
     * <li>KEY_VERIFIED {@link Boolean}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2TransferEnd(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Properties1'
        response.put("KEY_REQUEST_COMPLETE", Boolean.valueOf((payload[2] & 0x01) != 0));
        response.put("KEY_VERIFIED", Boolean.valueOf((payload[2] & 0x02) != 0));

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_COMMANDS_SUPPORTED_GET command.
     * <p>
     * S2 Commands Supported Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CommandsSupportedGet() {
        logger.debug("Creating command message SECURITY_2_COMMANDS_SUPPORTED_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_COMMANDS_SUPPORTED_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_COMMANDS_SUPPORTED_GET command.
     * <p>
     * S2 Commands Supported Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CommandsSupportedGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_COMMANDS_SUPPORTED_REPORT command.
     * <p>
     * S2 Commands Supported Report
     *
     * @param commandClass {@link List<Integer>}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CommandsSupportedReport(List<Integer> commandClass) {
        logger.debug("Creating command message SECURITY_2_COMMANDS_SUPPORTED_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_COMMANDS_SUPPORTED_REPORT);

        // Process 'Command Class'
        for (Integer valCommandClass : commandClass) {
            outputData.write(valCommandClass);
        }

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_COMMANDS_SUPPORTED_REPORT command.
     * <p>
     * S2 Commands Supported Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>COMMAND_CLASS {@link List}<{@link Integer}>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CommandsSupportedReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // We're using variable length fields, so track the offset
        int msgOffset = 2;

        // Process 'Command Class'
        List<Integer> valCommandClass = new ArrayList<Integer>();
        while (msgOffset < payload.length) {
            valCommandClass.add(payload[msgOffset] & 0xFF);
            msgOffset++;
        }
        response.put("COMMAND_CLASS", valCommandClass);

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_CAPABILITIES_GET command.
     * <p>
     * S2 Capabilities Get
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CapabilitiesGet() {
        logger.debug("Creating command message SECURITY_2_CAPABILITIES_GET version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_CAPABILITIES_GET);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_CAPABILITIES_GET command.
     * <p>
     * S2 Capabilities Get
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CapabilitiesGet(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the SECURITY_2_CAPABILITIES_REPORT command.
     * <p>
     * S2 Capabilities Report
     *
     * @param supportedSpans {@link Integer}
     * @param supportedMpans {@link Integer}
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getSecurity2CapabilitiesReport(Integer supportedSpans, Integer supportedMpans) {
        logger.debug("Creating command message SECURITY_2_CAPABILITIES_REPORT version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(SECURITY_2_CAPABILITIES_REPORT);

        // Process 'Supported SPANs'
        outputData.write(supportedSpans);

        // Process 'Supported MPANs'
        outputData.write(supportedMpans);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the SECURITY_2_CAPABILITIES_REPORT command.
     * <p>
     * S2 Capabilities Report
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>SUPPORTED_SPANS {@link Integer}
     * <li>SUPPORTED_MPANS {@link Integer}
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleSecurity2CapabilitiesReport(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Supported SPANs'
        response.put("SUPPORTED_SPANS", Integer.valueOf(payload[2]));

        // Process 'Supported MPANs'
        response.put("SUPPORTED_MPANS", Integer.valueOf(payload[3]));

        // Return the map of processed response data;
        return response;
    }
}
