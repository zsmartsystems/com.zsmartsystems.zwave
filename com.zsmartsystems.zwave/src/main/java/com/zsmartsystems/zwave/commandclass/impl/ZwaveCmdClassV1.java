/**
 * Copyright (c) 2016-2017 by the respective copyright holders.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zwave.commandclass.impl;

import java.io.ByteArrayOutputStream;
import java.util.HashMap;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to implement the Z-Wave command class <b>ZWAVE_CMD_CLASS</b> version <b>1</b>.
 * <p>
 * Z-Wave protocol Command Class
 * <p>
 * This class provides static methods for processing received messages (message handler) and
 * methods to get a message to send on the Z-Wave network.
 * <p>
 * Command class key is 0x01.
 * <p>
 * Note that this code is autogenerated. Manual changes may be overwritten.
 *
 * @author Chris Jackson - Initial contribution of Java code generator
 */
public class ZwaveCmdClassV1 {
    private static final Logger logger = LoggerFactory.getLogger(ZwaveCmdClassV1.class);

    /**
     * Integer command class key for ZWAVE_CMD_CLASS
     */
    public final static int COMMAND_CLASS_KEY = 0x01;

    /**
     * NOP Command Constant
     */
    public final static int ZWAVE_CMD_NOP = 0x00;
    /**
     * Node Info Command Constant
     * SDS10264-2
     */
    public final static int NODE_INFO = 0x01;
    /**
     * Request Node Info Command Constant
     * SDS10264-2
     */
    public final static int REQUEST_NODE_INFO = 0x02;
    /**
     * Assign Id Command Constant
     * SDS10264-2
     */
    public final static int ASSIGN_ID = 0x03;
    /**
     * Find Nodes In Range Command Constant
     * SDS10264-2
     */
    public final static int FIND_NODES_IN_RANGE = 0x04;
    /**
     * Get Nodes In Range Command Constant
     * SDS10264-2
     */
    public final static int GET_NODES_IN_RANGE = 0x05;
    /**
     * Node Range Info Command Constant
     * SDS10264-2
     */
    public final static int NODE_RANGE_INFO = 0x06;
    /**
     * Command Complete Command Constant
     * SDS10264-2
     */
    public final static int COMMAND_COMPLETE = 0x07;
    /**
     * Transfer Presentation Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_PRESENTATION = 0x08;
    /**
     * Transfer Node Info Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_NODE_INFO = 0x09;
    /**
     * Transfer Range Info Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_RANGE_INFO = 0x0A;
    /**
     * Transfer End Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_END = 0x0B;
    /**
     * Assign Return Route Command Constant
     * SDS10264-2
     */
    public final static int ASSIGN_RETURN_ROUTE = 0x0C;
    /**
     * New Node Registered Command Constant
     * SDS10264-2
     */
    public final static int NEW_NODE_REGISTERED = 0x0D;
    /**
     * New Range Registered Command Constant
     * SDS10264-2
     */
    public final static int NEW_RANGE_REGISTERED = 0x0E;
    /**
     * Transfer New Primary Complete Command Constant
     * SDS10264-2
     */
    public final static int TRANSFER_NEW_PRIMARY_COMPLETE = 0x0F;
    /**
     * Automatic Controller Update Start Command Constant
     */
    public final static int CMD_AUTOMATIC_CONTROLLER_UPDATE_START = 0x10;
    /**
     * SUC Node ID Command Constant
     */
    public final static int CMD_SUC_NODE_ID = 0x11;
    /**
     * Set SUC Command Constant
     */
    public final static int CMD_SET_SUC = 0x12;
    /**
     * Set SUC ACK Command Constant
     */
    public final static int CMD_SET_SUC_ACK = 0x13;
    /**
     * Assign SUC Return Route Command Constant
     */
    public final static int CMD_ASSIGN_SUC_RETURN_ROUTE = 0x14;
    /**
     * Static Route Request Command Constant
     */
    public final static int CMD_STATIC_ROUTE_REQUEST = 0x15;
    /**
     * Lost Command Constant
     * SDS10264-2
     */
    public final static int LOST = 0x16;
    /**
     * Accept Lost Command Constant
     * SDS10264-2
     */
    public final static int ACCEPT_LOST = 0x17;
    /**
     * NOP Power Command Constant
     */
    public final static int CMD_NOP_POWER = 0x18;
    /**
     * Reserve Node ID Command Constant
     */
    public final static int ZWAVE_CMD_RESERVE_NODE_IDS = 0x19;
    /**
     * Reserved ID Command Constant
     */
    public final static int CMD_RESERVED_IDS = 0x1A;
    /**
     * Cmd Nodes Exist Command Constant
     */
    public final static int CMD_NODES_EXIST = 0x1F;
    /**
     * Cmd Nodes Exist Reply Command Constant
     */
    public final static int CMD_NODES_EXIST_REPLY = 0x20;
    /**
     * Cmd Set Nwi Mode Command Constant
     */
    public final static int CMD_SET_NWI_MODE = 0x22;
    /**
     * Exclude Request Command Constant
     * INS13044
     */
    public final static int EXCLUDE_REQUEST = 0x23;
    /**
     * Assign Return Route Priority Command Constant
     */
    public final static int ASSIGN_RETURN_ROUTE_PRIORITY = 0x24;
    /**
     * Assign SUC Return Route Priority Command Constant
     */
    public final static int ASSIGN_SUC_RETURN_ROUTE_PRIORITY = 0x25;

    /**
     * Map holding constants for NodeInfoMaxBaudRate
     */
    private static Map<Integer, String> constantNodeInfoMaxBaudRate = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoCapability
     */
    private static Map<Integer, String> constantNodeInfoCapability = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoSecurity
     */
    private static Map<Integer, String> constantNodeInfoSecurity = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoProtocolVersion
     */
    private static Map<Integer, String> constantNodeInfoProtocolVersion = new HashMap<Integer, String>();

    /**
     * Map holding constants for NodeInfoSpeedExtension
     */
    private static Map<Integer, String> constantNodeInfoSpeedExtension = new HashMap<Integer, String>();

    static {
        // Constants for NodeInfoMaxBaudRate
        constantNodeInfoMaxBaudRate.put(0x00, "9_6_KBPS");
        constantNodeInfoMaxBaudRate.put(0x01, "40_KBPS");

        // Constants for NodeInfoCapability
        constantNodeInfoCapability.put(0x40, "ROUTING");
        constantNodeInfoCapability.put(0x80, "LISTENING");

        // Constants for NodeInfoSecurity
        constantNodeInfoSecurity.put(0x10, "BEAM_CAPABILITY");
        constantNodeInfoSecurity.put(0x01, "SECURITY");
        constantNodeInfoSecurity.put(0x20, "SENSOR_250MS");
        constantNodeInfoSecurity.put(0x02, "CONTROLLER");
        constantNodeInfoSecurity.put(0x40, "SENSOR_1000MS");
        constantNodeInfoSecurity.put(0x04, "SPECIFIC_DEVICE");
        constantNodeInfoSecurity.put(0x08, "ROUTING_SLAVE");
        constantNodeInfoSecurity.put(0x80, "OPTIONAL_FUNCTIONALITY");

        // Constants for NodeInfoProtocolVersion
        constantNodeInfoProtocolVersion.put(0x00, "Z_WAVE_VERSION_2_0");
        constantNodeInfoProtocolVersion.put(0x01, "Z_WAVE_VERSION_ZDK_5_0X_ZDK_4_2X");
        constantNodeInfoProtocolVersion.put(0x02, "Z_WAVE_VERSION_ZDK_4_5X_AND_ZDK_6_0X");

        // Constants for NodeInfoSpeedExtension
        constantNodeInfoSpeedExtension.put(0x00, "100_KBPS");
        constantNodeInfoSpeedExtension.put(0x01, "200_KBPS");
    }

    /**
     * Creates a new message with the ZWAVE_CMD_NOP command.
     * <p>
     * NOP
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getZwaveCmdNop() {
        logger.debug("Creating command message ZWAVE_CMD_NOP version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ZWAVE_CMD_NOP);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ZWAVE_CMD_NOP command.
     * <p>
     * NOP
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleZwaveCmdNop(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NODE_INFO command.
     * <p>
     * Node Info
     * <p>
     * SDS10264-2
     *
     * @param protocolVersion {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>Z_WAVE_VERSION_2_0
     *            <li>Z_WAVE_VERSION_ZDK_5_0X_ZDK_4_2X
     *            <li>Z_WAVE_VERSION_ZDK_4_5X_AND_ZDK_6_0X
     *            </ul>
     * @param maxBaudRate {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>9_6_KBPS
     *            <li>40_KBPS
     *            </ul>
     * @param routing {@link Boolean}
     * @param listening {@link Boolean}
     * @param security {@link Boolean}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>BEAM_CAPABILITY
     *            <li>SECURITY
     *            <li>SENSOR_250MS
     *            <li>CONTROLLER
     *            <li>SENSOR_1000MS
     *            <li>SPECIFIC_DEVICE
     *            <li>ROUTING_SLAVE
     *            <li>OPTIONAL_FUNCTIONALITY
     *            </ul>
     * @param controller {@link Boolean}
     * @param specificDevice {@link Boolean}
     * @param routingSlave {@link Boolean}
     * @param beamCapability {@link Boolean}
     * @param sensor250ms {@link Boolean}
     * @param sensor1000ms {@link Boolean}
     * @param optionalFunctionality {@link Boolean}
     * @param speedExtension {@link String}
     *            Can be one of the following -:
     *            <p>
     *            <ul>
     *            <li>100_KBPS
     *            <li>200_KBPS
     *            </ul>
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNodeInfo(String protocolVersion, String maxBaudRate, Boolean routing, Boolean listening,
            Boolean security, Boolean controller, Boolean specificDevice, Boolean routingSlave, Boolean beamCapability,
            Boolean sensor250ms, Boolean sensor1000ms, Boolean optionalFunctionality, String speedExtension) {
        logger.debug("Creating command message NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NODE_INFO);

        // Process 'Capability'
        int valCapability = 0;
        int varProtocolVersion = Integer.MAX_VALUE;
        for (Integer entry : constantNodeInfoProtocolVersion.keySet()) {
            if (constantNodeInfoProtocolVersion.get(entry).equals(protocolVersion)) {
                varProtocolVersion = entry;
                break;
            }
        }
        if (varProtocolVersion == Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Unknown constant value '" + protocolVersion + "' for protocolVersion");
        }
        valCapability |= varProtocolVersion & 0x07;
        int varMaxBaudRate = Integer.MAX_VALUE;
        for (Integer entry : constantNodeInfoMaxBaudRate.keySet()) {
            if (constantNodeInfoMaxBaudRate.get(entry).equals(maxBaudRate)) {
                varMaxBaudRate = entry;
                break;
            }
        }
        if (varMaxBaudRate == Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Unknown constant value '" + maxBaudRate + "' for maxBaudRate");
        }
        valCapability |= varMaxBaudRate << 3 & 0x38;
        valCapability |= routing ? 0x40 : 0;
        valCapability |= listening ? 0x80 : 0;
        outputData.write(valCapability);

        // Process 'Security'
        int valSecurity = 0;
        valSecurity |= security ? 0x01 : 0;
        valSecurity |= controller ? 0x02 : 0;
        valSecurity |= specificDevice ? 0x04 : 0;
        valSecurity |= routingSlave ? 0x08 : 0;
        valSecurity |= beamCapability ? 0x10 : 0;
        valSecurity |= sensor250ms ? 0x20 : 0;
        valSecurity |= sensor1000ms ? 0x40 : 0;
        valSecurity |= optionalFunctionality ? 0x80 : 0;
        outputData.write(valSecurity);

        // Process 'Properties1'
        int varSpeedExtension = Integer.MAX_VALUE;
        for (Integer entry : constantNodeInfoSpeedExtension.keySet()) {
            if (constantNodeInfoSpeedExtension.get(entry).equals(speedExtension)) {
                varSpeedExtension = entry;
                break;
            }
        }
        if (varSpeedExtension == Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Unknown constant value '" + speedExtension + "' for speedExtension");
        }
        outputData.write(varSpeedExtension & 0x07);

        // Process 'Basic Device Class'

        // Process 'Generic Device Class'

        // Process 'Specific Device Class'

        // Process 'Command Classes'

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NODE_INFO command.
     * <p>
     * Node Info
     * <p>
     * SDS10264-2
     * <p>
     * The output data {@link Map} has the following properties -:
     *
     * <ul>
     * <li>PROTOCOL_VERSION {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>Z_WAVE_VERSION_2_0
     * <li>Z_WAVE_VERSION_ZDK_5_0X_ZDK_4_2X
     * <li>Z_WAVE_VERSION_ZDK_4_5X_AND_ZDK_6_0X
     * </ul>
     * <li>MAX_BAUD_RATE {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>9_6_KBPS
     * <li>40_KBPS
     * </ul>
     * <li>ROUTING {@link Boolean}
     * <li>LISTENING {@link Boolean}
     * <li>SECURITY {@link Boolean}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>BEAM_CAPABILITY
     * <li>SECURITY
     * <li>SENSOR_250MS
     * <li>CONTROLLER
     * <li>SENSOR_1000MS
     * <li>SPECIFIC_DEVICE
     * <li>ROUTING_SLAVE
     * <li>OPTIONAL_FUNCTIONALITY
     * </ul>
     * <li>CONTROLLER {@link Boolean}
     * <li>SPECIFIC_DEVICE {@link Boolean}
     * <li>ROUTING_SLAVE {@link Boolean}
     * <li>BEAM_CAPABILITY {@link Boolean}
     * <li>SENSOR_250MS {@link Boolean}
     * <li>SENSOR_1000MS {@link Boolean}
     * <li>OPTIONAL_FUNCTIONALITY {@link Boolean}
     * <li>SPEED_EXTENSION {@link String}
     * Can be one of the following -:
     * <p>
     * <ul>
     * <li>100_KBPS
     * <li>200_KBPS
     * </ul>
     * </ul>
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Process 'Capability'
        response.put("PROTOCOL_VERSION", constantNodeInfoProtocolVersion.get(payload[2] & 0x07));
        response.put("MAX_BAUD_RATE", constantNodeInfoMaxBaudRate.get((payload[2] & 0x38) >> 3));
        response.put("ROUTING", Boolean.valueOf((payload[2] & 0x40) != 0));
        response.put("LISTENING", Boolean.valueOf((payload[2] & 0x80) != 0));

        // Process 'Security'
        response.put("SECURITY", Boolean.valueOf((payload[3] & 0x01) != 0));
        response.put("CONTROLLER", Boolean.valueOf((payload[3] & 0x02) != 0));
        response.put("SPECIFIC_DEVICE", Boolean.valueOf((payload[3] & 0x04) != 0));
        response.put("ROUTING_SLAVE", Boolean.valueOf((payload[3] & 0x08) != 0));
        response.put("BEAM_CAPABILITY", Boolean.valueOf((payload[3] & 0x10) != 0));
        response.put("SENSOR_250MS", Boolean.valueOf((payload[3] & 0x20) != 0));
        response.put("SENSOR_1000MS", Boolean.valueOf((payload[3] & 0x40) != 0));
        response.put("OPTIONAL_FUNCTIONALITY", Boolean.valueOf((payload[3] & 0x80) != 0));

        // Process 'Properties1'
        response.put("SPEED_EXTENSION", constantNodeInfoSpeedExtension.get(payload[4] & 0x07));

        // Process 'Basic Device Class' (optional)
        if (true) {
        }

        // Process 'Generic Device Class'

        // Process 'Specific Device Class'

        // Process 'Command Classes'

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the REQUEST_NODE_INFO command.
     * <p>
     * Request Node Info
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getRequestNodeInfo() {
        logger.debug("Creating command message REQUEST_NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(REQUEST_NODE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the REQUEST_NODE_INFO command.
     * <p>
     * Request Node Info
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleRequestNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_ID command.
     * <p>
     * Assign Id
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignId() {
        logger.debug("Creating command message ASSIGN_ID version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_ID);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_ID command.
     * <p>
     * Assign Id
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignId(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the FIND_NODES_IN_RANGE command.
     * <p>
     * Find Nodes In Range
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getFindNodesInRange() {
        logger.debug("Creating command message FIND_NODES_IN_RANGE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(FIND_NODES_IN_RANGE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the FIND_NODES_IN_RANGE command.
     * <p>
     * Find Nodes In Range
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleFindNodesInRange(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the GET_NODES_IN_RANGE command.
     * <p>
     * Get Nodes In Range
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getGetNodesInRange() {
        logger.debug("Creating command message GET_NODES_IN_RANGE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(GET_NODES_IN_RANGE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the GET_NODES_IN_RANGE command.
     * <p>
     * Get Nodes In Range
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleGetNodesInRange(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NODE_RANGE_INFO command.
     * <p>
     * Node Range Info
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNodeRangeInfo() {
        logger.debug("Creating command message NODE_RANGE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NODE_RANGE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NODE_RANGE_INFO command.
     * <p>
     * Node Range Info
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNodeRangeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the COMMAND_COMPLETE command.
     * <p>
     * Command Complete
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCommandComplete() {
        logger.debug("Creating command message COMMAND_COMPLETE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(COMMAND_COMPLETE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the COMMAND_COMPLETE command.
     * <p>
     * Command Complete
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCommandComplete(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_PRESENTATION command.
     * <p>
     * Transfer Presentation
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferPresentation() {
        logger.debug("Creating command message TRANSFER_PRESENTATION version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_PRESENTATION);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_PRESENTATION command.
     * <p>
     * Transfer Presentation
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferPresentation(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_NODE_INFO command.
     * <p>
     * Transfer Node Info
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferNodeInfo() {
        logger.debug("Creating command message TRANSFER_NODE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_NODE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_NODE_INFO command.
     * <p>
     * Transfer Node Info
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferNodeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_RANGE_INFO command.
     * <p>
     * Transfer Range Info
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferRangeInfo() {
        logger.debug("Creating command message TRANSFER_RANGE_INFO version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_RANGE_INFO);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_RANGE_INFO command.
     * <p>
     * Transfer Range Info
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferRangeInfo(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_END command.
     * <p>
     * Transfer End
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferEnd() {
        logger.debug("Creating command message TRANSFER_END version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_END);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_END command.
     * <p>
     * Transfer End
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferEnd(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_RETURN_ROUTE command.
     * <p>
     * Assign Return Route
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignReturnRoute() {
        logger.debug("Creating command message ASSIGN_RETURN_ROUTE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_RETURN_ROUTE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_RETURN_ROUTE command.
     * <p>
     * Assign Return Route
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignReturnRoute(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NEW_NODE_REGISTERED command.
     * <p>
     * New Node Registered
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNewNodeRegistered() {
        logger.debug("Creating command message NEW_NODE_REGISTERED version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NEW_NODE_REGISTERED);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NEW_NODE_REGISTERED command.
     * <p>
     * New Node Registered
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNewNodeRegistered(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the NEW_RANGE_REGISTERED command.
     * <p>
     * New Range Registered
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getNewRangeRegistered() {
        logger.debug("Creating command message NEW_RANGE_REGISTERED version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(NEW_RANGE_REGISTERED);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the NEW_RANGE_REGISTERED command.
     * <p>
     * New Range Registered
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleNewRangeRegistered(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the TRANSFER_NEW_PRIMARY_COMPLETE command.
     * <p>
     * Transfer New Primary Complete
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getTransferNewPrimaryComplete() {
        logger.debug("Creating command message TRANSFER_NEW_PRIMARY_COMPLETE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(TRANSFER_NEW_PRIMARY_COMPLETE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the TRANSFER_NEW_PRIMARY_COMPLETE command.
     * <p>
     * Transfer New Primary Complete
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleTransferNewPrimaryComplete(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_AUTOMATIC_CONTROLLER_UPDATE_START command.
     * <p>
     * Automatic Controller Update Start
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdAutomaticControllerUpdateStart() {
        logger.debug("Creating command message CMD_AUTOMATIC_CONTROLLER_UPDATE_START version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_AUTOMATIC_CONTROLLER_UPDATE_START);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_AUTOMATIC_CONTROLLER_UPDATE_START command.
     * <p>
     * Automatic Controller Update Start
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdAutomaticControllerUpdateStart(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SUC_NODE_ID command.
     * <p>
     * SUC Node ID
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSucNodeId() {
        logger.debug("Creating command message CMD_SUC_NODE_ID version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SUC_NODE_ID);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SUC_NODE_ID command.
     * <p>
     * SUC Node ID
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSucNodeId(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_SUC command.
     * <p>
     * Set SUC
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetSuc() {
        logger.debug("Creating command message CMD_SET_SUC version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_SUC);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_SUC command.
     * <p>
     * Set SUC
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetSuc(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_SUC_ACK command.
     * <p>
     * Set SUC ACK
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetSucAck() {
        logger.debug("Creating command message CMD_SET_SUC_ACK version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_SUC_ACK);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_SUC_ACK command.
     * <p>
     * Set SUC ACK
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetSucAck(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_ASSIGN_SUC_RETURN_ROUTE command.
     * <p>
     * Assign SUC Return Route
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdAssignSucReturnRoute() {
        logger.debug("Creating command message CMD_ASSIGN_SUC_RETURN_ROUTE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_ASSIGN_SUC_RETURN_ROUTE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_ASSIGN_SUC_RETURN_ROUTE command.
     * <p>
     * Assign SUC Return Route
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdAssignSucReturnRoute(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_STATIC_ROUTE_REQUEST command.
     * <p>
     * Static Route Request
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdStaticRouteRequest() {
        logger.debug("Creating command message CMD_STATIC_ROUTE_REQUEST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_STATIC_ROUTE_REQUEST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_STATIC_ROUTE_REQUEST command.
     * <p>
     * Static Route Request
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdStaticRouteRequest(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the LOST command.
     * <p>
     * Lost
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getLost() {
        logger.debug("Creating command message LOST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(LOST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the LOST command.
     * <p>
     * Lost
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleLost(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ACCEPT_LOST command.
     * <p>
     * Accept Lost
     * <p>
     * SDS10264-2
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAcceptLost() {
        logger.debug("Creating command message ACCEPT_LOST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ACCEPT_LOST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ACCEPT_LOST command.
     * <p>
     * Accept Lost
     * <p>
     * SDS10264-2
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAcceptLost(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NOP_POWER command.
     * <p>
     * NOP Power
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNopPower() {
        logger.debug("Creating command message CMD_NOP_POWER version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NOP_POWER);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NOP_POWER command.
     * <p>
     * NOP Power
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNopPower(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ZWAVE_CMD_RESERVE_NODE_IDS command.
     * <p>
     * Reserve Node ID
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getZwaveCmdReserveNodeIds() {
        logger.debug("Creating command message ZWAVE_CMD_RESERVE_NODE_IDS version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ZWAVE_CMD_RESERVE_NODE_IDS);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ZWAVE_CMD_RESERVE_NODE_IDS command.
     * <p>
     * Reserve Node ID
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleZwaveCmdReserveNodeIds(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_RESERVED_IDS command.
     * <p>
     * Reserved ID
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdReservedIds() {
        logger.debug("Creating command message CMD_RESERVED_IDS version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_RESERVED_IDS);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_RESERVED_IDS command.
     * <p>
     * Reserved ID
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdReservedIds(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NODES_EXIST command.
     * <p>
     * Cmd Nodes Exist
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNodesExist() {
        logger.debug("Creating command message CMD_NODES_EXIST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NODES_EXIST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NODES_EXIST command.
     * <p>
     * Cmd Nodes Exist
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNodesExist(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_NODES_EXIST_REPLY command.
     * <p>
     * Cmd Nodes Exist Reply
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdNodesExistReply() {
        logger.debug("Creating command message CMD_NODES_EXIST_REPLY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_NODES_EXIST_REPLY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_NODES_EXIST_REPLY command.
     * <p>
     * Cmd Nodes Exist Reply
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdNodesExistReply(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the CMD_SET_NWI_MODE command.
     * <p>
     * Cmd Set Nwi Mode
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getCmdSetNwiMode() {
        logger.debug("Creating command message CMD_SET_NWI_MODE version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(CMD_SET_NWI_MODE);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the CMD_SET_NWI_MODE command.
     * <p>
     * Cmd Set Nwi Mode
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleCmdSetNwiMode(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the EXCLUDE_REQUEST command.
     * <p>
     * Exclude Request
     * <p>
     * INS13044
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getExcludeRequest() {
        logger.debug("Creating command message EXCLUDE_REQUEST version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(EXCLUDE_REQUEST);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the EXCLUDE_REQUEST command.
     * <p>
     * Exclude Request
     * <p>
     * INS13044
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleExcludeRequest(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_RETURN_ROUTE_PRIORITY command.
     * <p>
     * Assign Return Route Priority
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignReturnRoutePriority() {
        logger.debug("Creating command message ASSIGN_RETURN_ROUTE_PRIORITY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_RETURN_ROUTE_PRIORITY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_RETURN_ROUTE_PRIORITY command.
     * <p>
     * Assign Return Route Priority
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignReturnRoutePriority(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }

    /**
     * Creates a new message with the ASSIGN_SUC_RETURN_ROUTE_PRIORITY command.
     * <p>
     * Assign SUC Return Route Priority
     *
     * @return the {@link byte[]} array with the command to send
     */
    static public byte[] getAssignSucReturnRoutePriority() {
        logger.debug("Creating command message ASSIGN_SUC_RETURN_ROUTE_PRIORITY version 1");

        ByteArrayOutputStream outputData = new ByteArrayOutputStream();
        outputData.write(COMMAND_CLASS_KEY);
        outputData.write(ASSIGN_SUC_RETURN_ROUTE_PRIORITY);

        return outputData.toByteArray();
    }

    /**
     * Processes a received frame with the ASSIGN_SUC_RETURN_ROUTE_PRIORITY command.
     * <p>
     * Assign SUC Return Route Priority
     *
     * @param payload the {@link byte[]} payload data to process
     * @return a {@link Map} of processed response data
     */
    public static Map<String, Object> handleAssignSucReturnRoutePriority(byte[] payload) {
        // Create our response map
        Map<String, Object> response = new HashMap<String, Object>();

        // Return the map of processed response data;
        return response;
    }
}
